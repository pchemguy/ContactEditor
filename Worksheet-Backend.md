It is assumed that the form displays all of the fields from the table. Further, the names of the corresponding controls are set to match exactly the names of the fields in the table. And they also match the keys in the data dictionary of the DataRecordModel. With this convention, data can be transferred between the form and the DataRecordModel and between DataRecordModel and DataTableModel without ever hardcoding any field names.

In the current implementation, the "Contacts" worksheet stores the table filled with fake generated data and is used by the DataTableWSheet. The name of the worksheet is not hardcoded either. It is supplied as a part of the ConnectionString parameter to the factory, which for the worksheet backend is expected to be in the form of workbook filename with extension" (as returned by Thisworkbook\.name) followed by the exclamation mark, and followed by the worksheet name. The present implementation, however, makes no attempts to handle, for example, unopened workbooks. The only confirmed test runs have been executed with the target worksheet being in the same file as the VBA code. The name of the worksheet is not actually used, however, as the backend expects that the table name must also be supplied, which in this case is a globally scoped named range. It is expected that the first row of this range contains field names, and the first column is the id column. Two more named ranges are expected with names formed as concatenation of the given table name and "Body" for the data range (without the header) and "Id" suffix for the id column data (without the header). While the "Body" range can be straightforwardly calculated from the table range, the lack of necessary support in Excel/VBA makes such calculations not very intuitive and complicates the code. With this convention, the backend collects the field names for the first row of the table, avoiding the need for hardcoding specific names.  

For example, presenter initializes DataTableWSheet via the corresponding interface with table name "Contacts", which is a (dynamic) named range, "ContactsId" range refers to the "id" column, and "ContactsBody" range refers to the data area without the header. "ContactsHeader" range is also defined and refers to the header row only. (N.B.: because these ranges are dynamic and defined using a formula, these names are not shown in the range name / address bar (top left corner)).

"ContactBrowser" worksheet is used by the DataRecordWSheet backend. Saved "ContactBrowser" data is also used to populate the form at the start. The convention here is as follows. Again, only named ranges are used, no Excel addresses. Each field from the Record/Table has a corresponding cell, and the name of that cell is set to match the name of the field. This convention means that in principle, once DataTableWSheet has pulled the table including the field names from the header, this information is sufficient to pull the data by the DataRecordWSheet from the corresponding worksheet. Nevertheless, DataRecordWSheet collects the field names independently (well, this is an exploratory project after all) going through the Names collection of the Workbook object. DataRecordWSheet filters (keeps) all members matching all of the following:
- Name.RefersTo starts with the name of the worksheet supplied to the DataRecordWSheet constructor;
- target range is a single cell range;
- the value of an adjacent cell either above or to the left of the target cell contains a text that also matches the field name.

For example, the cell ContactBrowser!E5 is a single cell named range "LastName", which matches the value of the cell ContactBrowser!D5, name of the field in the table on the "Contacts" worksheet, and the name of the TextBox control on the UserForm.