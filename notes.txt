#### Factory-Constructor pattern - parametrized class instantiation

A pair of a factory and a custom constructor performs parametrized class instantiation. The default factory *Create* and the default constructor *Init* are defined on the class's default interface only. Both methods have the same parameter signature but different return values. The Factory method should be a function returning a class instance, and the Constructor method should be a sub with no return value. The factory method called on the default (predeclared) class's instance (enabled via the "Predeclared" attribute) generates a new class instance (via the New operator) and then, to perform initialization, calls instance's constructor with all received arguments. For example,

To simulate rudimentary introspection, *Class* and *Self* getters can also be defined. The *Class* getter returns the class's default instance. If a class instance presents a non-default interface, *Self* should return it as well.

```vba
'''' ===== DataTableADODB.cls ===== ''''

Implements IDataTableStorage

'''' Encapsulated private fields
Private Type TDataTableADODB
	' Define private fields here
End Type
Private this As TDataTableADODB

'''' A boilerplate template for the default factory
'''' This method is called on the default predeclared class instance
Public Function Create(ByVal Model As DataTableModel, _
					   ByVal ConnectionString As String, _
					   ByVal TableName As String) As IDataTableStorage
    Dim Instance As DataTableADODB
    Set Instance = New DataTableADODB
    Instance.Init Model, ConnectionString, TableName
    Set Create = Instance
End Function

'''' Constructor
'''' This method is called on the default interface of the newly generated class instance
Public Sub Init(ByVal Model As DataTableModel, _
				ByVal ConnectionString As String, _
				ByVal TableName As String)
	' Check input parameters and initialize private data fields here.
End Sub

'''' Self attribute defined on the default interface
Public Property Get Self() As IDataTableStorage
    Set Self = Me
End Property

'''' Class attribute defined on the default interface
Public Property Get Class() As DataTableADODB
    Set Class = DataTableADODB
End Property
```

#### Abstract factory

An abstract factory class has two default factory methods. The *Create* method follows the same convention as for a regular class. It is available on the default predeclared instance of the abstract factory only and generates factory instances:

```vba
'''' ===== DataTableFactory.cls ===== ''''

Implements IDataTableFactory

'''' A boilerplate template for the default factory
'''' This method is called on the default predeclared class instance
Public Function Create(ByVal ClassName As String) As IDataTableFactory
    Dim Instance As DataTableFactory
    Set Instance = New DataTableFactory
    Instance.Init ClassName
    Set Create = Instance
End Function
```
The other factory is *CreateInstance*. It must be available on non-default factory instances, but it can also be available on the default instance. This factory generates instances of the target class, e.g.:

```vba
'''' ===== DataTableFactory.cls ===== ''''

Public Function CreateInstance(ByVal ClassName As String, _
                               ByVal Model As DataTableModel, _
                               ByVal ConnectionString As String, _
                               ByVal TableName As String) As IDataTableStorage
    Select Case ClassName
        Case "ADODB"
            Set CreateInstance = DataTableADODB.Create(Model, ConnectionString, TableName)
        Case "Worksheet"
            Set CreateInstance = DataTableWSheet.Create(Model, ConnectionString, TableName)
        Case "CSV"
            Set CreateInstance = DataTableCSV.Create(Model, ConnectionString, TableName)
        Case Else
            Dim errorDetails As TError
            With errorDetails
                .Number = ErrNo.NotImplementedErr
                .Name = "NotImplementedErr"
                .Source = "IDataTableFactory"
                .Description = "Unsupported backend: " & ClassName
                .Message = .Description
            End With
            RaiseError errorDetails
    End Select
End Function

Private Function IDataTableFactory_CreateInstance( _
					ByVal Model As DataTableModel, _
			        ConnectionString As String, _
					ByVal TableName As String) As IDataTableStorage
    Set IDataTableFactory_CreateInstance = CreateInstance( _
	    this.ClassName, Model, ConnectionString, TableName)
End Function
```

#### Factory return type

Typically, a class's factory should return an instance of that class. Further, if the class implements an interface, it is customarily to define the factory's return type as an instance of such an interface (see code in the first section). *Abstract factory pattern* may be used to encapsulate a group of classes implementing the same interface. *CreateInstance* method of an abstract factory should call a concrete factory of the selected class, so the *CreateInstance* method and individual concrete factories should return an instance of the interface class. This pattern is illustrated by the code in the previous section and in [Fig. 1](#FigDataTableModel) with *DataTableXXX* family, *IDataTableStorage*, and *DataTableFactory*.

<a name="FigDataTableModel"></a>
<img src="https://raw.githubusercontent.com/pchemguy/ContactEditor/develop/Assets/Diagrams/Class%20Diagram%20-%20Table.svg" alt="FigDataTableModel" width="100%" />
<p align="center"><b>Figure 1. DataTableModel class diagram</b></p>

Factories may be specified as returning Object/Variant as a means of implementing polymorphism. However, this approach imposes limitations on static code analysis, compile-time checks, and IntelliSense.

#### Extensibility considerations

Consider [Fig. 1](#FigDataTableModel). The goal is to extend functionality provided by *DataTableADODB* class, while preserving backward compatibility. First, the new functionality can be added to *DataTableADODB* via new methods or via etxtensions to existing methods without breaking compatibility. This new functionality needs to be exposed on the interface. Changing *IDataTableStorage*, however, will break compatibility, so the new functionality must be exposed via a separate new interface *IDataTableStorageV2*, which should also expose all functionality provided by *IDataTableStorage*. Now, each *DataTableXXX* class may implement  *IDataTableStorageV2* in addition to *IDataTableStorage* (if, e.g., *DataTableCSV* class does not provide functionality exposed via *IDataTableStorageV2*, it does not have to implement it). Since factories of the *DataTableXXX* classes must return a common interface, each class implementing both interfaces should implement a second factory, e.g.:

```vba
'''' ===== DataTableADODB.cls ===== ''''

Implements IDataTableStorage
Implements IDataTableStorageV2

'''' Default factory for IDataTableStorage
Public Function Create(ByVal Model As DataTableModel, _
					   ByVal ConnectionString As String, _
					   ByVal TableName As String) As IDataTableStorage
    Dim Instance As DataTableADODB
    Set Instance = New DataTableADODB
    Instance.Init Model, ConnectionString, TableName
    Set Create = Instance
End Function

'''' Default factory for IDataTableStorageV2
Public Function CreateV2(ByVal Model As DataTableModel, _
					     ByVal ConnectionString As String, _
					     ByVal TableName As String) As IDataTableStorageV2
    Dim Instance As DataTableADODB
    Set Instance = New DataTableADODB
    Instance.Init Model, ConnectionString, TableName
    Set Create = Instance
End Function
```

Based on [Fig. 1](#FigDataTableModel), *IDataTableStorage* is related to two other classes. *DataTableFactory.CreateInstance* reurns a new *IDataTableStorage* instance and *DataTableManager* incorporates

Let us suppose that we have the following goal. We have a data handling application that uses several storage back-end classes, such as *CSV*, *ADODB*, etc., responsible for retrieving stored table data. These back-end classes are programmed against the *IDataTableStorage* interface and abstract factory *IDataTableFactory* is used to generate an *IDataTableStorage* instance. We now want to extend the functionality provided via the *IDataTableStorage* while preserving backward compatibility.

#### Multiple interfaces

Class interfaces enable better decoupling of components. Some classes implement multiple interfaces (analog of multiple inheritance). While their instances expose the implemented interfaces, a given reference exposes only one interface at a time. One possible approach to making all interfaces conveniently available is as follows. "Self\<Interface name\>" methods defined on the class's default interface return references to the instance's respective interfaces. Additionally, the *CreateDefault* constructor defined on the default interface generates class instances exposing the default interface.


[RubberDuck Examples]: https://github.com/rubberduck-vba/examples