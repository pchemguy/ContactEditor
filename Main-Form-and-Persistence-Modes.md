The main form acts as a table browser, displaying one record at a time. The name of each form control holding a field value matches the name of the field. ContactEditorPresenter transfers the data between the form and RecordTableManager(DataCompositeManager)->RecordModel(DataRecordModel) by matching the names of the controls and field names on DataRecordModel instance. The only place, where the control/field names needed to appear in the code explicitly, is in the code-behind of the form wiring "Change" events handlers for individual controls.  

The form also presents a radio control determining persistence mode. Changes made to the form are immediately saved into the DataRecordModel, which in turn is saved to its backend if Apply or Ok buttons are pressed. Nothing else is saved if table updating is disabled. Otherwise, every time the  DataRecordModel is saved to its backend, it also updates the corresponding record in the DataTableModel. When the option "On apply" is selected, DataTableModel is saved to its backend after each update. When the option "On exit" is selected, DataTableModel is saved with all changes at once only when the Ok button is pressed, closing the form. 

The UserForm - view/viewModel - ContactEditorForm is displayed as *modeless*, so custom UserForm events pass control to the appropriate routines in the presenter (ContactEditorPresenter). For this reason, a WithEvents view reference is defined as a module-level field in the presenter, and a module-level reference to the presenter is defined in the entry point module. The Presenter also defines a second view reference as the IDialogView interface, containing the main entry point for the view.  

Since UserForm events cannot be programmatically enabled/disabled (at least straightforwardly) at run time, the SuppressEvents Boolean flag is added to the ContactEditorModel to cancel event processing when the form fields are programmatically updated.  
